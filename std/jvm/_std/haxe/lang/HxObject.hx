package haxe.lang;import haxe.lang.IEquatable;private typedef StdType = Type;//private typedef StdClass<T> = Class<T>;/** * ... * @author waneck */@:native('haxe.lang.HxObject')private class HxObject implements IHxObject{	}@:native('haxe.lang.IHxObject')private interface IHxObject{	}@:native('haxe.lang.DynamicObject')@:replaceReflectionprivate class DynamicObject extends HxObject, implements Dynamic{	public function toString():String	{		var ret = new StringBuf();		ret.add("{");		var first = true;		for (f in Reflect.fields(this))		{			if( first )				first = false;			else				ret.add(",");			ret.add(" "); ret.add(f);			ret.add(" : ");			ret.add(Reflect.field(this, f));		}		if (!first) ret.add(" ");		ret.add("}");				return ret.toString();	}		@:replaceReflection private function _getClass():Class	{		//Dynamic Objects always return null for their type		return null;	}		@:replaceReflection private static function getClassStatic():Class	{		return null;	}}@:native('haxe.lang.Class')private class Class extends HxObject{	private var classProxy:IHxObject;	public function new(cls)	{		this.classProxy = cls;	}		@:functionBody('			return classProxy.getClass();	')	public function nativeType():jvm.native.lang.Class<Dynamic>	{		return null;	}		public function toString():String untyped	{		return Type.getClassName(untyped this);	}}@:native('haxe.lang.NativeClassWrapper')@:replaceReflectionprivate class NativeClassWrapper extends Class, implements IEquatable{	private var native:jvm.native.lang.Class<Dynamic>;		public function new(native:jvm.native.lang.Class<Dynamic>)	{		super(null);		this.native = native;	}		override public function nativeType():jvm.native.lang.Class<Dynamic>	{		return native;	}		/* INTERFACE haxe.lang.IEquatable */		public function equals(to:Dynamic):Bool 	{		return (Std.is(to, NativeClassWrapper) && cast(to, NativeClassWrapper).native == native);	}		@:functionBody('		return null;	')	@:replaceReflection private function getField(field:String, isStatic:Bool, throwErrors:Bool, isCheck:Bool):Dynamic	{		return null;	}		@:replaceReflection private function getField_f(field:String, isStatic:Bool, throwErrors:Bool):Float	{		return cast getField(field, isStatic, throwErrors, false);	}		@:functionBody('		return null;	')	@:replaceReflection private function setField(field:String, isStatic:Bool, val:Dynamic):Dynamic	{		return null;	}		@:replaceReflection private function setField_f(field:String, isStatic:Bool, val:Float):Float	{		return cast setField(field, isStatic, val);	}		@:functionBody('		return null;	')	@:replaceReflection private function invokeField(field:String, isStatic:Bool, dynArgs:Array<Dynamic>):Dynamic	{		return null;	}		@:functionBody('			')	@:replaceReflection private function classFields(baseArr:Array<String>):Void	{			}		@:functionBody('			')	@:replaceReflection private function getFields(baseArr:Array<String>, isInstanceFields:Bool):Void	{			}		@:functionBody('		return null;	')	@:replaceReflection private function create(args:Array<Dynamic>):Dynamic	{		return null;	}		@:functionBody('		return null;	')	@:replaceReflection private function createEmpty():Dynamic	{		return null;	}		@:replaceReflection private function _getClass():Class	{		//class wrappers are always null for getClass		return null;	}		@:replaceReflection private static function getClassStatic():Class	{		return null;	}		}@:native('haxe.lang.Enum')//@:skip_ctorprivate class Enum{	@:readonly private var index:Int;	@:readonly private var params:Array<{}>;		public function new(index:Int, params:Array<{}>)	{		this.index = index;		this.params = params;	}		@:final public function getTag():String	{		var cl:Dynamic = StdType.getClass(this);		return cl.constructs[index];	}		public function toString():String	{		if (params == null) return getTag();		var ret = new StringBuf();		ret.add(getTag()); ret.add("(");				var first = true;				for (p in params)		{			if (first)				first = false;			else				ret.add(", ");			ret.add(p);		}				ret.add(")");		return ret.toString();	}		public function equals(obj:Dynamic)	{		if (obj == this) //we cannot use == as .Equals !			return true;				var obj:Enum = cast obj;		var ret = obj != null && Std.is(obj, StdType.getClass(this)) && obj.index == this.index;		if (!ret) 			return false;		if (obj.params == this.params)			return true;		var len = 0;		if (obj.params == null || this.params == null || (len = this.params.length) != obj.params.length)			return false;				for (i in 0...len)		{			if (obj.params[i] != this.params[i])				return false;		}		return true;	}}