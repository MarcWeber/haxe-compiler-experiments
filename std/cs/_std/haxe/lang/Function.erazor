package haxe.lang;

@@:classContents
('

	protected readonly uint curriedArgsLen;
    protected readonly uint arity;
    protected readonly uint type;
	protected readonly double[] curried_d;
	protected readonly object[] curried_o;
	
	public Function(uint type, uint arity, object[] curried_o, double[] curried_l)
	{{
		if (type != 0 && type != 1 && type != 2) throw new System.ArgumentOutOfRangeException("Function type can only be 0 (object), 1 (int) or 2 (double)")
		
		this.type = type;
		this.arity = arity;
		if (curried_o != null)
		{{
			this.curried_o = curried_o;
			this.curried_d = curried_d;
			this.curriedArgsLen = curried_o.Length;
		}} else {{
			this.curriedArgsLen = 0;
		}}
	}}
	
	public static void FunctionCheckArguments(uint calledArity)
	{{
		calledArity += (curried_o != null ? curried_o.Length : 0);
		
		if (arity != calledArity)
		{{
			throw new haxe.lang.HaxeException("Invalid function arity. Expected " + arity + "; got " + calledArity);
		}}
	}}

@for (arity in 0...max_arity)
{
@for (type in ["", "_d"])
{
	public virtual object invoke@(arity)@(type)(
	@for (t in "d", "o")
	{
		@for (i in 0...arity)
		{
			
		}
	}
	)
	{{
		FunctionCheckArguments(@arity);
		switch (arity)
        {{
	@for (caseArity in 0...max_arity)
	{
		@if (caseArity < arity){
			case @caseArity:
		} else if (caseArity == arity)
		{
			@if (caseArity > 0)
			{
				throw new haxe.lang.HaxeException("too many arguments");
			}
			case @caseArity:
				switch(type) {{ case 0: throw new System.NotImplementedException(); case 1: return invoke_d(); default: throw new haxe.lang.HaxeException("assert " + type) }};
		} else {
			case @caseArity:
				return invoke@(caseArity)(
				@{ var first = true; }
				@for (t in ["d", "o"])
				{
					@for(i in 0...caseArity)
					{
						@if (first) { @{first = false;} } else {, }
						curried_@(t)[@(i)]
					}
				}
				);
		}
	}
		
            case 0: switch (type) {{ case 0: throw new System.NotImplementedException(); case 1: return invoke_d(); default: throw new System.Exception("function assert: " + type); }}
            case 1: return invoke1(curried_l[0], curried_o[0]);
            case 2: return invoke2(curried_l[0], curried_l[1], curried_o[0], curried_o[1]);
            case 3: return invoke3(curried_l[0], curried_l[1], curried_l[2], curried_o[0], curried_o[1], curried_o[2]);
            case 4: return invoke4(curried_l[0], curried_l[1], curried_l[2], curried_l[3], curried_o[0], curried_o[1], curried_o[2], curried_o[3]);
            case 5: return invoke5(curried_l[0], curried_l[1], curried_l[2], curried_l[3], curried_l[4], curried_o[0], curried_o[1], curried_o[2], curried_o[3], curried_o[4]);
            default: return invokeDynamic(null, null);
        }}
	}}
	
	public virtual double invoke0_d()
	{{
		
	}}
}
}
')
@:abstract @:nativegen @:native("haxe.lang.Function") private class Function 
{
	
}