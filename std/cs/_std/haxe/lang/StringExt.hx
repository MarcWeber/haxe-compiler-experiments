package haxe.lang;import haxe.lang.Function;private typedef NativeString = String;@:keep @:nativegen @:native("haxe.lang.StringExt") private class StringExt{	@:functionBody('			if ( ((uint) index) >= me.Length)				return null;			else				return new string(me[index], 1);	')	public static function charAt(me:NativeString, index:Int):NativeString	{		return null;	}		@:functionBody('			if ( ((uint) index) >= me.Length)				return default(haxe.lang.Null<int>);			else				return new haxe.lang.Null<int>((int)me[index], true);	')	public static function charCodeAt(me:NativeString, index:Int):Null<Int>	{		return null;	}		@:functionBody('			uint sIndex = (startIndex.hasValue) ? ((uint) startIndex.@value) : 0;			if (sIndex >= me.Length)				return -1;			return me.IndexOf(str, (int)sIndex);	')	public static function indexOf(me:NativeString, str:NativeString, ?startIndex:Int):Int	{		return -1;	}		@:functionBody('			int sIndex = (startIndex.hasValue) ? (startIndex.@value) : (me.Length - 1);			if (sIndex > me.Length)				sIndex = me.Length - 1;			else if (sIndex < 0)				return -1;			return me.LastIndexOf(str, sIndex);	')	public static function lastIndexOf(me:NativeString, str:NativeString, ?startIndex:Int):Int	{		return -1;	}		@:functionBody('			string[] native = me.Split(new string[] { delimiter }, System.StringSplitOptions.None);			return new Array<object>(native);	')	public static function split(me:NativeString, delimiter:NativeString):Array<NativeString>	{		return null;	}		@:functionBody('			int meLen = me.Length;			int targetLen = meLen;			if (len.hasValue)			{				targetLen = len.@value;				if (targetLen == 0)					return "";				if( pos != 0 && targetLen < 0 ){					return "";				}			}						if( pos < 0 ){				pos = meLen + pos;				if( pos < 0 ) pos = 0;			} else if( targetLen < 0 ){				targetLen = meLen + targetLen - pos;			}			if( pos + targetLen > meLen ){				targetLen = meLen - pos;			}			if ( pos < 0 || targetLen <= 0 ) return "";						return me.Substring(pos, targetLen);	')	public static function substr(me:NativeString, pos:Int, ?len:Int):NativeString	{		return null;	}		@:functionBody('		int endIdx;		int len = me.Length;		if ( !endIndex.hasValue ) {			endIdx = len;		} else if ( (endIdx = endIndex.@value) < 0 ) {			endIdx = 0;		} else if ( endIdx > len ) {			endIdx = len;		}				if ( startIndex < 0 ) {			startIndex = 0;		} else if ( startIndex > len ) {			startIndex = len;		}				if ( startIndex > endIdx ) {			int tmp = startIndex;			startIndex = endIdx;			endIdx = tmp;		}				return me.Substring(startIndex, endIdx - startIndex);	')	public static function substring(me:NativeString, startIndex:Int, ?endIndex:Int):NativeString	{		return null;	}		@:functionBody('			return me.ToLower();	')	public static function toLowerCase(me:NativeString):NativeString	{		return null;	}		@:functionBody('			return me.ToUpper();	')	public static function toUpperCase(me:NativeString):NativeString	{		return null;	}		public static function toNativeString(me:NativeString):NativeString	{		return me;	}		@:functionBody('			return new string( (char) code, 1 );	')	public static function fromCharCode(code:Int):NativeString	{		return null;	}}@:keep @:nativegen @:native('haxe.lang.StringRefl') private class StringRefl{	public static var fields = ["length", "toUpperCase", "toLowerCase", "charAt", "charCodeAt", "indexOf", "lastIndexOf", "split", "substr", "substring"];		public static function handleGetField(str:NativeString, f:NativeString, throwErrors:Bool):Dynamic	{		switch(f)		{			case "length": return str.length;			case "toUpperCase", "toLowerCase", "charAt", "charCodeAt", "indexOf", "lastIndexOf", "split", "substr", "substring":				return new Closure(str, f, 0);			default:				if (throwErrors)					throw "Field not found: '" + f + "' in String";				else					return null;		}	}		public static function handleCallField(str:NativeString, f:NativeString, args:Array<Dynamic>):Dynamic	{		var _args:Array<Dynamic> = [str];		if (args == null)			args = _args;		else			args = _args.concat(args);				return Runtime.slowCallField(StringExt, f, args);	}}